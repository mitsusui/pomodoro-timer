import os
from dotenv import load_dotenv
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from datetime import datetime, date, timedelta, timezone
from typing import Optional
from sqlmodel import Field, Session, SQLModel, create_engine, select
from plyer import notification

# Define DB model(schema): class info is saved in metadata(SQLModel.metadata)
class PomodoroLog(SQLModel, table=True):
    #id is automatically generated by using optional[int]
    id: Optional[int] = Field(default=None, primary_key=True)
    #save the data in UTC format to display it correctly anywhere in the world (web browser will convert the datetime to their localtime)
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc)) 
    #default value is "Work session"
    task_name: str = Field(default="Work session")

# Connection setteings
load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")
engine = create_engine(DATABASE_URL)


# Check existing table name and create table if the same table does not exist
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# app instance will be associated with all commands
app = FastAPI()
# Permission for access to static files explicitly (clients can access those files through their browser)
app.mount("/static", StaticFiles(directory="static"), name="static")
# templates is a key of server side rendering (You can input data such as data retreived from db into HTML by using Jinja2 template)
templates = Jinja2Templates(directory="templates")

# const: daily goal (Currently this value is static)
POMODORO_GOAL_ROUNDS = 5

# Initialization Hook
@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    # Read index.html (currently not insert any data from db here, but you can)
    return templates.TemplateResponse("index.html", {"request": request})

# server notification function
@app.post("/notify")
async def send_notification():
    # Save data into db
    with Session(engine) as session: # Open session (automatically close the session when this process completes)
        log = PomodoroLog() # generate PomodoroLog class instance (all data will created automatically with default settings)
        session.add(log) # staging
        session.commit() # finalize
    
    # server side notification
    notification.notify(title="Completed!", message="Successfully saved your work!")
    
    return {"status": "success"}



@app.get("/logs")
async def get_logs():
    # return repetition count and completion time of the day
    today_start = datetime.combine(date.today(), datetime.min.time())
    today_end = today_start + timedelta(days=1)
    
    with Session(engine) as session:
        # retrieve all logs for today in ascending order as datetime object
        rows = session.exec(
            select(PomodoroLog)
            .where(PomodoroLog.timestamp >= today_start, PomodoroLog.timestamp < today_end)
            .order_by(PomodoroLog.timestamp)
        ).all()
        # It allows you to insert the data into completed_times val
        # You can still use completed_times outside of the With scope
        completed_times = [r.timestamp.strftime("%H:%M:%S") for r in rows] # list comprehension
    return {
        "goal_rounds": POMODORO_GOAL_ROUNDS,
        "completed_count": len(completed_times),
        "completed_times": completed_times,
    }